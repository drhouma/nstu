# Практическое занятие №2: Сортировка и поиск

__CPU__

*Имя модели*:                      Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz

*Степпинг*:                        12

*CPU МГц*:                         2100.000

*CPU max MHz*:                     4200,0000

*CPU min MHz*:                     400,0000

*CPU(s)*:                          8

*On-line CPU(s) list*:             0-7

*Потоков на ядро*:                 2

## Часть 1: сортировка

__*Полученные в результате опытов данные*__
Количество чисел N=1000000=1e+6

| алгоритм \ диапазон чисел |  -1000 : 1000  | -50000000:50000000 |
|:-------------------------:|:--------------:|:------------------:|
| std::sort                 | 0.314826       | 0.45922            |
| count_sort                | 0.0184182      | 0.875442           |

* Выводы
    * Когда есть массив, строго ограниченный малым диапазоном (-1000 : 1000), выгодно использовать count_sort
    * Когда массив ограничен диапазоном, размер которого больше или равен исходному массиву, алгоритм count_sort не выгоден

## Часть 2: сортировка

__*Полученные в результате опытов данные*__
количество вставляемых элементов N =           1000000
количество строк М, по которым ведется поиск = 100000

| хэш ф-ия \ метод | set            | get                | всего коллизий     |
|:----------------:|:--------------:|:------------------:|:------------------:|
| hash1            | 0.313661       | 0.025194           | 4608               |
| hash2            | 0.337348       | 0.0314034          | 147288             |
| shift            | 0.483374       | 0.0621659          | 289312             |
| stl::map         | 2.70202        | 1.67425            |        ---         |


* Выводы
    * Скорость работы целиком хэш таблицы полностью зависит от выбранной функции, и чем проще решение - тем лучше